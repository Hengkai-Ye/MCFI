In the MCFI paper, we use three scratch registers to instrument an indirect
branch. However, we may use only two to get the same job done, and the analysis
is shown below. The instrumentation is used for a return instructions.

Try:
  popq %rcx
  movq %gs:Idx, %rdi
1:cmpq %rdi, %gs:(%rcx)
  jne  Lcheck
  jmpq *%rcx

Lcheck:
2:movq  %gs:(%rcx), %rsi
  testb $1, %sil
  jne   Lreport
  cmpl  %esi, %ecx
  jne   Try
Lreport:
  leaq  Try, %rdi    # which indirect branch
  movq  %rcx, %rsi   # intentional control-flow target
  movq  $Idx, %rdx   # which BID entry
                     # BID
                     # TID
  jmp   MCFIViolationReport

The following cases might happen:

* At label 1, BID == TID, check passed.

* At label 1, TID.validity == 0, the CFI violation should be detected by later checks

  At label 2, TID is re-read from memory, and the following cases might happen: 
    if BID == TID, which might happen due to online activation of targets in PICFI, CFI violation would be detected
    else if TID.validity == 0, CFI violation
    else if TID.version != BID.version, the current check will be aborted and retried, perhaps querying the updated CFG
    else if BID.ECN != TID.ECN, CFI violation

* At label 1, TID.validity == 1 and TID.version != BID.version, the transaction should be aborted and retried

  At label 2, TID is re-read from memory, and the following cases might happen:
    if BID == TID, this is impossible
    else if TID.validity == 0, the target code has been deactivated, which is impossible, because the runtime must 
                               know not every thread has executed a system call at least once.
    else if TID.version != BID.version, retry
    else if TID.ECN != TID.ECN, impossible because the versions must be different

* At label 1, TID.validity == 1 and TID.version == BID.version and TID.ECN != BID.ECN, should have CFI violation

  At label 2, TID is re-read from memory, and the following cases might happen:
    if BID == TID, impossible
    else if TID.validity == 0, CFI violation
    else if TID.version != BID.version, retry
    else BID.ECN != TID.ECN, CFI violation

Procedure Linkage Entry (PLT) Design

When two ELF program binaries are linked, they are linked through
a special PLT section, which are usually like below

1: jmpq this_call(%rip)
2: push$ this_call_index
3: jmpq dynamic_loader

Line 1 is an indirect jump through memory which actually references
its relevant entry in the GOT table in section .got.plt. Initially
The entry contains the address of line 2 above, which subsequently
invokes the dynamic_loader (line 3) to resolve the actual library
value and replace the old entry value. Since line 1 is also an indirect
jump whose target depends on attacker-controllable memory, it should
be protected by MCFI. However, we can use some memory mapping tricks
to avoid instrumentation of the PLT entry.

In detail, we put section .got.plt in its own set of memory pages. These
memory pages are mapped read-only so that modification of them would
crash the program. Further, we create virtual pages outside of the
MCFI sandbox and map them to the same physical pages where the
.got.plt section is mapped to. All modification to these pages are
conducted by the trusted rock runtime. In this way, the PLT entries are
as fast as their native counterparts if the GOT entry has been resolved.

